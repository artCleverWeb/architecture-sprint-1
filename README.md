# Задание 1
## Уровень 1. Проектирование

### Границы микрофронтенда
1. Авторизация и регистрация
   - Авторизация пользователя
   - Регистрация пользователя
   - Выход из учетной записи
2. Карточки мест
   - Добавить карточку
   - Удалить карточку
   - Поставить лайл
   - Убрать лайк
3. Профиль пользователя
   - Редактировании информации о текущем пользователи
   - Добавление\смена аватарки теущего пользователя

### Выбор фреймворка
В качестве инструмента сборки используем Webpack Module Federation. Метод реализации микрофронтендов RunTime.
Если необходимо учесть seo оптимизацию можно использовать метод реализации гибридный RealTime

При выборе фреймворка Webpack Module Federation опирался на:
1. Поддержка динамически загружаемых модулей и компонентов
2. Сложность и быстрота интеграции фреймворка
3. Наличие общего кода, который можно вынести в отдельный метод
4. Все модули приложения реализованы на едином фронтенд фреймворки - react

## Уровень 2. Планированиерование
### Структура микрофронтендов
```bash
/auth
   /src
      /blocks
         /auth-form      // стили для  формы регистрации
         /login          // стилия для формы авторизации
      /components
         /Logins.js      // Компонент Авторизация 
         /Register.js    // Компонент Регистрации 
         /InfoTooltip.js // Компонент всплывающих подсказок
      /images            // Картинки необходимые в рамках работы микрофронтенда
      /utils
         /auth.js        // методы Api для работы с авторизацией и регистрацией

/host
   /src
      /blocks
         /content        // Стили контентной области
         /footer         // Стили футера
         /header         // Стили шапки
         /page           // Базовые стили
      /components
         /App.js         // Компонент с базовыми методами приложения
         /Footer.js      // Компонент с футером
         /Header.js      // Компонент с шапкой
         /Main.js        // Компонент главной страницы
         /ProtectedRoute.js // Компонент маршрутизации
      /contexts
         /CurrentUserContext.js   Объект контекста CurrentUserContext экспортируется из отдельного файла директории contexts
      /images            // Картинки необходимые в рамках работы микрофронтенда

/places
   /src
      /blocks
         /card             // Стили для блока с карточкой места
         /places           // Стили для списка мест
      /components          
         /AddPlacePopup.js // Компонент добавления карточки места
         /Card.js          // Компонент отображения карточки места и обработки событий лайков
         /ImagePopup.js    // Компонент всплывающего слоя
      /images              // Картинки необходимые в рамках работы микрофронтенда
      /utils
         api.js            // Api методы для обработки запросов на получения списка карточек и добавления карточки места. а так же обработки лайков
         

/profile
   /src
      /blocks
         /profile             // Стили для отображения профиля пользователя
      /components
         /EditAvaterPopup.js  // Компонент загрузки аватарки пользователя
         /EditProfilePopup.js // Компонент редактирования профиля пользователя
      /images                 // Картинки необходимые в рамках работы микрофронтенда
      /utils
         /api.js              // Api методы для работы с профилем пользователя
         
/shared
   /src
      /blocks
         /popup            // Стили для всплывающего слоя
      /components
         /PopupWithForm    // Компонент всплывающего слоя
         
```

# Задание 2

Ссылка на диаграмму - [Диаграма](https://disk.yandex.ru/d/XEZxm1TbiiETyQ)

## Выделены основные компоненты приложения:
- **Сервис Авторизации, регистрации, аутентификации** - добавляет, обновляет учетную запись пользователя, формирует и валидирует jwt токен. Так же, аутентификацию, генерацию и обновление jwt токена можно было вынести в отдельную систему на Keycloak
- **Сервис товаров** - добавляет, изменяет и удаляет товар в профиле пользваотеля
- **Сервис Услуг** - добавляет, изменяет и удаляет услугу в профиле пользваотеля. В целом, можно совместить  услуги и товары в одном модуле
- **Сервис Поиска** - строим на основе ElasticSearch \ Sphinx получем идентификаторы товаров \ услуг и запрашиваем в родительских сервисах
- **Сервис заявок на техн. поддержку** - Добавляется заявка на техн. поддержку, спец. техн. поддержки могут изменить статус заявки. Администраторы валидировать заявку
- **Сервис отчетов** - формирование и выборка отчетов. Накапливать данные можно в колоночной БД ClickHouse. Сформированные данные в СУБД Postgres. "Сырые" данные можно получать подписавшись на событие шины EventBus. Поток данных будет зависить от исходных требований бизнеса. В качестве альтернативы можно расмотреть формирование формирование событий по каждому событию каждого модуля системы, на которые подпишется сервис аналитики и отчетов.
- **Сервис аукционов** - Создание, редактирование аукционов, обновление ставки пользователя на аукционе. События изменения статуса аукциона вызывает Отправку событий в EventBus
- **Сервис аппеляций** - Создание заявки на аппеляцию пользователем. Регистрация заявки и обновления статуса на аппеляцию администратором системы
- **Сервис Заказов** - Создание, подтверждение, изменения и получения информации о заказах для пользователя системы. Так же, у пользователя есть возможность инициировать оплату заказу, что в свою очередь вызывает запрос на иниирование оплаты в модуле оплат. При изменении статуса транзакции модуля оплаты происходит изменения статуса заказа. Модуль отправляет событие в EventBus на любое изменение статуса заказа.
- **Сервис оплат** - Формирвоание оплаты, интеграция с внешней системой оплаты, изменении статусов оплат. Поскольку требований к системе не описано, так же не описаны дальнейшие события при изменении статуса транзакции было выбрано простое решение интеграции с модулем заказа. В качестве альтернативы можно рассмотреть паттерн SAGA, с обработкой методов do и undo на кажое событие взаимодействия систем.
- **Сервис Нотификации** - Сервис подписывается на события шины EventBus, запрашивает необходимые данные у смежных сервисов по протоколу gRPC и отправляет нотификацию. Предусмотрены следующие виды нотификации: при регистрации нвого пользователя, при изенении состояния заказа, при изменении состояния аукциона. Данный подход обеспечивает гибкость решения за счет инкапсуляции сервиса и возможности масштабирования за счет подписки на события смежных модулей. Данные необходимые для обработки событий нотификации сервис получает по протоколу gRPC, что упрощает внедрения разных типов нотификации со стороны модулей - модулю достаточно отправить событие в EventBus, сервис уведомлений. опираясь на тип события сам получит исходные данные и отправит уведомление. В качестве альтернативы можно рассмотреть реализацию, когда сервис уведомлений получает полный \ условно полынй набор данных необходимых для отправки уведомлений.

Выделены основные фронтенды приложения:
- Клиентский фроентед - можно разбить на отдельные микрофротенды, реализация на фреймворках с гибридным RunTime методом реализации.
- Панель Администратора - выделена в отдельный интерфейс
- Панель технической поддержки - выделена в отдельный интерфейс

Фронтенд "общается" с сревисами через API Gateaway с настроенным балансировщиком.  
